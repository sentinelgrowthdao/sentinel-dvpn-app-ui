"use strict";(self.webpackChunksentinel_dvpn_ui=self.webpackChunksentinel_dvpn_ui||[]).push([[703],{7390:()=>{try{self["workbox:strategies:7.0.0"]&&_()}catch(e){}},214:(e,t,s)=>{s.d(t,{kV:()=>b});var n=s(8288),a=s(8142),r=s(4178),i=s(540),o=s(5694),c=s(4953),h=s(8381),l=s(7593),u=s(7791),d=s(7390);function f(e){return"string"==typeof e?new Request(e):e}class w{constructor(e,t){this._cacheKeys={},Object.assign(this,t),this.event=t.event,this._strategy=e,this._handlerDeferred=new h.c,this._extendLifetimePromises=[],this._plugins=[...e.plugins],this._pluginStateMap=new Map;for(const e of this._plugins)this._pluginStateMap.set(e,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(e){const{event:t}=this;let s=f(e);if("navigate"===s.mode&&t instanceof FetchEvent&&t.preloadResponse){const e=await t.preloadResponse;if(e)return e}const n=this.hasCallback("fetchDidFail")?s.clone():null;try{for(const e of this.iterateCallbacks("requestWillFetch"))s=await e({request:s.clone(),event:t})}catch(e){if(e instanceof Error)throw new r.R("plugin-error-request-will-fetch",{thrownErrorMessage:e.message})}const a=s.clone();try{let e;e=await fetch(s,"navigate"===s.mode?void 0:this._strategy.fetchOptions);for(const s of this.iterateCallbacks("fetchDidSucceed"))e=await s({event:t,request:a,response:e});return e}catch(e){throw n&&await this.runCallbacks("fetchDidFail",{error:e,event:t,originalRequest:n.clone(),request:a.clone()}),e}}async fetchAndCachePut(e){const t=await this.fetch(e),s=t.clone();return this.waitUntil(this.cachePut(e,s)),t}async cacheMatch(e){const t=f(e);let s;const{cacheName:n,matchOptions:a}=this._strategy,r=await this.getCacheKey(t,"read"),i=Object.assign(Object.assign({},a),{cacheName:n});s=await caches.match(r,i);for(const e of this.iterateCallbacks("cachedResponseWillBeUsed"))s=await e({cacheName:n,matchOptions:a,cachedResponse:s,request:r,event:this.event})||void 0;return s}async cachePut(e,t){const s=f(e);await(0,u.w)(0);const n=await this.getCacheKey(s,"write");if(!t)throw new r.R("cache-put-with-no-response",{url:(0,o.R)(n.url)});const a=await this._ensureResponseSafeToCache(t);if(!a)return!1;const{cacheName:i,matchOptions:h}=this._strategy,d=await self.caches.open(i),w=this.hasCallback("cacheDidUpdate"),p=w?await(0,c.e)(d,n.clone(),["__WB_REVISION__"],h):null;try{await d.put(n,w?a.clone():a)}catch(e){if(e instanceof Error)throw"QuotaExceededError"===e.name&&await(0,l.w)(),e}for(const e of this.iterateCallbacks("cacheDidUpdate"))await e({cacheName:i,oldResponse:p,newResponse:a.clone(),request:n,event:this.event});return!0}async getCacheKey(e,t){const s=`${e.url} | ${t}`;if(!this._cacheKeys[s]){let n=e;for(const e of this.iterateCallbacks("cacheKeyWillBeUsed"))n=f(await e({mode:t,request:n,event:this.event,params:this.params}));this._cacheKeys[s]=n}return this._cacheKeys[s]}hasCallback(e){for(const t of this._strategy.plugins)if(e in t)return!0;return!1}async runCallbacks(e,t){for(const s of this.iterateCallbacks(e))await s(t)}*iterateCallbacks(e){for(const t of this._strategy.plugins)if("function"==typeof t[e]){const s=this._pluginStateMap.get(t),n=n=>{const a=Object.assign(Object.assign({},n),{state:s});return t[e](a)};yield n}}waitUntil(e){return this._extendLifetimePromises.push(e),e}async doneWaiting(){let e;for(;e=this._extendLifetimePromises.shift();)await e}destroy(){this._handlerDeferred.resolve(null)}async _ensureResponseSafeToCache(e){let t=e,s=!1;for(const e of this.iterateCallbacks("cacheWillUpdate"))if(t=await e({request:this.request,response:t,event:this.event})||void 0,s=!0,!t)break;return s||t&&200!==t.status&&(t=void 0),t}}class p{constructor(e={}){this.cacheName=i.n.getRuntimeName(e.cacheName),this.plugins=e.plugins||[],this.fetchOptions=e.fetchOptions,this.matchOptions=e.matchOptions}handle(e){const[t]=this.handleAll(e);return t}handleAll(e){e instanceof FetchEvent&&(e={event:e,request:e.request});const t=e.event,s="string"==typeof e.request?new Request(e.request):e.request,n=undefined,a=new w(this,{event:t,request:s,params:"params"in e?e.params:void 0}),r=this._getResponse(a,s,t),i=undefined;return[r,this._awaitComplete(r,a,s,t)]}async _getResponse(e,t,s){let n;await e.runCallbacks("handlerWillStart",{event:s,request:t});try{if(n=await this._handle(t,e),!n||"error"===n.type)throw new r.R("no-response",{url:t.url})}catch(a){if(a instanceof Error)for(const r of e.iterateCallbacks("handlerDidError"))if(n=await r({error:a,event:s,request:t}),n)break;if(!n)throw a}for(const a of e.iterateCallbacks("handlerWillRespond"))n=await a({event:s,request:t,response:n});return n}async _awaitComplete(e,t,s,n){let a,r;try{a=await e}catch(r){}try{await t.runCallbacks("handlerDidRespond",{event:n,request:s,response:a}),await t.doneWaiting()}catch(e){e instanceof Error&&(r=e)}if(await t.runCallbacks("handlerDidComplete",{event:n,request:s,response:a,error:r}),t.destroy(),r)throw r}}const m=(e,t)=>`Using ${e} to respond to '${(0,o.R)(t.url)}'`,g=e=>{e&&(a.v.groupCollapsed("View the final response here."),a.v.log(e||"[No response returned]"),a.v.groupEnd())};class _ extends(null){async _handle(e,t){const s=[];let n=await t.cacheMatch(e),a;if(n)0;else{0;try{n=await t.fetchAndCachePut(e)}catch(e){e instanceof Error&&(a=e)}0}if(!n)throw new WorkboxError("no-response",{url:e.url,error:a});return n}}class y extends(null){async _handle(e,t){const s=await t.cacheMatch(e);if(!s)throw new WorkboxError("no-response",{url:e.url});return s}}const k={cacheWillUpdate:async({response:e})=>200===e.status||0===e.status?e:null};class v extends p{constructor(e={}){super(e),this.plugins.some((e=>"cacheWillUpdate"in e))||this.plugins.unshift(k),this._networkTimeoutSeconds=e.networkTimeoutSeconds||0}async _handle(e,t){const s=[];const n=[];let a;if(this._networkTimeoutSeconds){const{id:r,promise:i}=this._getTimeoutPromise({request:e,logs:s,handler:t});a=r,n.push(i)}const i=this._getNetworkPromise({timeoutId:a,request:e,logs:s,handler:t});n.push(i);const o=await t.waitUntil((async()=>await t.waitUntil(Promise.race(n))||await i)());if(!o)throw new r.R("no-response",{url:e.url});return o}_getTimeoutPromise({request:e,logs:t,handler:s}){let n;const a=undefined;return{promise:new Promise((t=>{const a=undefined;n=setTimeout((async()=>{t(await s.cacheMatch(e))}),1e3*this._networkTimeoutSeconds)})),id:n}}async _getNetworkPromise({timeoutId:e,request:t,logs:s,handler:n}){let a,r;try{r=await n.fetchAndCachePut(t)}catch(e){e instanceof Error&&(a=e)}return e&&clearTimeout(e),!a&&r||(r=await n.cacheMatch(t)),r}}class C extends p{constructor(e={}){super(e),this._networkTimeoutSeconds=e.networkTimeoutSeconds||0}async _handle(e,t){let s,n;try{const s=[t.fetch(e)];if(this._networkTimeoutSeconds){const e=(0,u.w)(1e3*this._networkTimeoutSeconds);s.push(e)}if(n=await Promise.race(s),!n)throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`)}catch(e){e instanceof Error&&(s=e)}if(!n)throw new r.R("no-response",{url:e.url,error:s});return n}}class b extends p{constructor(e={}){super(e),this.plugins.some((e=>"cacheWillUpdate"in e))||this.plugins.unshift(k)}async _handle(e,t){const s=[];const n=t.fetchAndCachePut(e).catch((()=>{}));t.waitUntil(n);let a=await t.cacheMatch(e),i;if(a)0;else{0;try{a=await n}catch(e){e instanceof Error&&(i=e)}}if(!a)throw new r.R("no-response",{url:e.url,error:i});return a}}}}]);